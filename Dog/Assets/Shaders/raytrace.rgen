#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_scalar_block_layout : enable

layout(set = 0, binding = 0) uniform Uniforms
{
    mat4 projectionView;
    mat4 projection;
    mat4 view;
} uniforms;

layout(set = 1, binding = 0, rgba32f) uniform image2D outImage;
layout(set = 1, binding = 1) uniform accelerationStructureEXT topLevelAS;

layout(location = 0) rayPayloadEXT HitPayload {
    vec3 color;
    vec3 attenuation;
    int depth;
    vec3 nextRayOrigin;
    vec3 nextRayDir;    
    bool stop;    
    float cost;
} payload;

/**
 * Generates a 'Jet' style heatmap color based on the reference image.
 * Input 'x' is a value from 0.0 to 1.0.
 */
vec3 getHeatmapColor(float x) {
    x = clamp(x, 0.0, 1.0);
    vec3 col = vec3(0.0);

    // Define the 6 key colors for the 5 segments in the gradient
    const vec3 c0 = vec3(0.3, 0.0, 0.8); // Dark Purple/Blue
    const vec3 c1 = vec3(0.0, 0.0, 1.0); // Blue
    const vec3 c2 = vec3(0.0, 1.0, 1.0); // Cyan
    const vec3 c3 = vec3(0.0, 1.0, 0.0); // Green
    const vec3 c4 = vec3(1.0, 1.0, 0.0); // Yellow
    const vec3 c5 = vec3(1.0, 0.0, 0.0); // Red

    // Linearly interpolate (mix) between the key colors
    if (x < 0.2) {
        float t = (x - 0.0) / 0.2;
        col = mix(c0, c1, t);
    } else if (x < 0.4) {
        float t = (x - 0.2) / 0.2;
        col = mix(c1, c2, t);
    } else if (x < 0.6) {
        float t = (x - 0.4) / 0.2;
        col = mix(c2, c3, t);
    } else if (x < 0.8) {
        float t = (x - 0.6) / 0.2;
        col = mix(c3, c4, t);
    } else { // x >= 0.8
        float t = (x - 0.8) / 0.2;
        col = mix(c4, c5, t);
    }
    
    return col;
}

void main() 
{
    // Get dispatch indices
    uvec3 launchID = gl_LaunchIDEXT;
    uvec3 launchSize = gl_LaunchSizeEXT;

    vec2 uv = (vec2(launchID.xy) + 0.5) / vec2(launchSize.xy);
    vec2 clipCoords = uv * 2.0 - 1.0;

    // Compute ray origin and direction
    vec4 viewCoords = inverse(uniforms.projection) * vec4(clipCoords, 1.0, 1.0);
    viewCoords /= viewCoords.w;

    vec3 origin = (inverse(uniforms.view) * vec4(0.0, 0.0, 0.0, 1.0)).xyz;
    vec3 direction = normalize((inverse(uniforms.view) * vec4(viewCoords.xyz, 0.0)).xyz);

    // Initialize payload
    payload.color = vec3(0.0);
    payload.attenuation = vec3(1.0); // Start with full white throughput
    // payload.seed = gl_LaunchIDEXT.y * gl_LaunchSizeEXT.x + gl_LaunchIDEXT.x + 0/*frameCount*/; // Initialize seed
    payload.depth = 0;
    payload.stop = false;
    payload.cost = 0;

    const float SPAWN_COST = 1.0;
    const int MAX_DEPTH = 8;
    for (int i = 0; i < MAX_DEPTH; ++i)
    {
        payload.depth = i;
        payload.cost += SPAWN_COST;

        traceRayEXT(
            topLevelAS,         // acceleration structure
            gl_RayFlagsNoneEXT, // ray flags
            0xFF,               // cull mask
            0, 0, 0,            // SBT record offsets
            origin,             // ray origin
            0.001,              // tmin
            direction,          // ray direction
            1e38,               // tmax
            0                   // payload location
        );

        if (payload.stop /*|| payload.weight < 0.01*/)
        {
            break;
        }

        origin = payload.nextRayOrigin;
        direction = payload.nextRayDir;
    }

    // Tone map + gamma
    payload.color = payload.color / (payload.color + vec3(1.0));
    payload.color = pow(payload.color, vec3(1.0 / 2.2));

    // imageStore(outImage, ivec2(launchID.xy), vec4(payload.color, 1.0));

    // Show cost
    const float maxCost = 204.0;

    // This logarithmic mapping is still fine
    float mapped = log(1.0 + payload.cost) / log(1.0 + maxCost);
    mapped = clamp(mapped, 0.0, 1.0);

    // Call the new heatmap function instead of turbo()
    vec3 col = getHeatmapColor(mapped);

    imageStore(outImage, ivec2(launchID.xy), vec4(col, 1.0));
}